// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Texture2D<float4> devColorIn;
//SamplerState sampler_devColorIn;
RWTexture2D<float4> devColorIn;

//Texture2D<float4> devAccumColorIn;
//SamplerState sampler_devAccumColorIn;
RWTexture2D<float4> devAccumColorIn;

//Texture2D<float4> devAccumMomentIn;
//SamplerState sampler_devAccumMomentIn;
RWTexture2D<float4> devAccumMomentIn;

// GBuffer
//Texture2D<float4> _NormalTexture;
//SamplerState sampler_NormalTexture;
RWTexture2D<float4> _NormalTexture;

//Texture2D<float4> _LastNormalTexture;
//SamplerState sampler_LastNormalTexture;
RWTexture2D<float4> _LastNormalTexture;

//Texture2D<float4> _PositionTexture;
//SamplerState sampler_PositionTexture;
RWTexture2D<float4> _PositionTexture;

//Texture2D<float4> _LastPositionTexture;
//SamplerState sampler_LastPositionTexture;
RWTexture2D<float4> _LastPositionTexture;


//Texture2D<float4> _MotionTexture;
//SamplerState sampler_MotionTexture;
RWTexture2D<float4> _MotionTexture;

//output
RWTexture2D<float4> devAccumColorOut;
RWTexture2D<float4> devAccumMomentOut;

bool _FirstFrame;


float luminance(float3 color) {
    return dot(color, float3(.2126f, .7152f, .0722f));
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint2 pixel = id.xy;
	uint width, height;
    devAccumColorOut.GetDimensions(width, height);

	if (id.x >= width || id.y >= height) {
		return;
	}

	uint2 lastUV = _MotionTexture[id.xy].xy * uint2(width, height);

    float4 norm = _NormalTexture[id.xy];
    float3 position = _PositionTexture[id.xy].xyz;
	

	float3 color = devColorIn[pixel];

	float lum = luminance(color);

	float3 accumColor = float3(0, 0, 0);
	float3 accumMoment = float3(0, 0, 0);

	if (_FirstFrame || norm.w <= 0) {
		accumColor = color;
		accumMoment = float3( lum, lum * lum, 0.f );
	}
	else {
		int count = 0;
		for(int i = 0; i <= 1; i++)
		{
			for(int j = 0; j <= 1; j++){
				int x = lastUV.x + i;
				int y = lastUV.y + j;
				if(x >= width || y >= height) continue;
				uint2 uv = uint2(x, y);
				float4 lastNorm = _LastNormalTexture[uv];
				if (abs(dot(norm.xyz, lastNorm.xyz)) < .1f) {
					continue;
				}
				if(abs(norm.w - lastNorm.w) > 0.1){
					continue;
				}
				
				//float3 lastPos =  _LastPositionTexture[uv].xyz;
				//if(distance(position , lastPos) > 0.1){
				//	continue;
                //}
				float3 lastColor = devAccumColorIn[uv].xyz;
				float3 lastMoment = devAccumMomentIn[uv].xyz;
				accumColor += lastColor;
				accumMoment += lastMoment;
				count ++;

            }
        }
		if(count > 0)
		{
			const float Alpha = .2f;
			accumColor = lerp(accumColor / count, color, Alpha);
			accumMoment = float3(lerp(accumMoment.rg/count, float2(lum, lum * lum), Alpha), accumMoment.b/count + 1.f);
		}
		else
		{
			accumColor = color;
			accumMoment = float3( lum, lum * lum, 0.f );
        }

	}
 

	devAccumColorOut[pixel] = float4(accumColor, 1.0);
	devAccumMomentOut[pixel] = float4(accumMoment, 1);
}
